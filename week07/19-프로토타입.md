## 19장: 프로토타입
---

### 19.3 프로토타입 객체

객체간 상속을 구현한다. 그래서 프로토타입을 상속받으면 자식 객체는 그 프로퍼티를 자유롭게 사용할 수 있다.

```jsx
function Panda(age, name){
    this.age = age;
    this.name = name;
}

Panda.prototype.eat = function(){
    if(this.age >= 1) console.log("나는 죽순을 먹어용");
    else console.log("나는 우유를 먹어용");
}

const fubao = new Panda(4, '푸바오');
```

### `prototype` vs `__proto__` vs `Object.getPrototypeOf` 
- `Panda.prototype`: `fuboa` 객체가 상속받는 프로토타입 객체
- `fubao.__proto__`: `fubao`의 프로토타입 객체를 가져오는 비표준 접근법
- `Object.getPrototypeOf(fubao)`: `fubao`의 프로토타입 객체를 가져오는 표준 접근법

### `__proto__`

> `fubao.__proto__`: `fubao`의 프로토타입 객체를 가져오는 비표준 접근법

[[Prototype]]` 슬롯에 간접적으로 접근

// TODO
<details>
  <summary>
    내부슬롯
  </summary>
  자바스크립트는 원칙적으로 내부 슬롯과 내부 메서를 직접적으로 접근 또는 호출 할 수 없음. 그러나 `__proto__`를 통해 내부 슬롯 [[Prototype]]을 접근할 수 있음.
</details>

<img width="314" alt="image" src="https://github.com/dev-hamster/study-js-deep-dive/assets/123740296/c34707e6-81e4-464f-b570-a247db7ad859">


**`__proto__`를 사용하는 이유**
```jsx
const fubao = {};
const aiBao = {};

// DO NOT
fubao.__proto__ = aibao;
aibao.__proto__ = fubak;
```
프로토타입을 교체할 수 없게 만들어 프로토타입 체인의 순환참조를 막는다.
프로토타입 체인은 단방향 링크드 리스트로 구현되어야 한다.

// TODO

### `prototype`
> `Panda.prototype`: `fuboa` 객체가 상속받는 프로토타입 객체
생성자 함수로서 호출할 수 있는 함수인 constructor만 소유함

**`__proto__` vs `prototype`**
|구분|소유|값|사용 주체|사용목적
|--|--|--|--|--|
|`__proto__`|모든 객체|프로토타입 참조|모든 객체|객체가 자신의 프로터타입에 접근, 프로토타입 교체
|`prototype`|constructor|프로토타입 참조|생성자 함수|생성자 함수가 자신이 생성할 객체의 프로토타입을 할당하기 위해 사용

### constructor 프로퍼티와 생성자 함수
자기자신을 가리킴
생성자 함수가 생성될 때, 이 연결이 이뤄짐


---
### ?
p272. 이 연결은 생성자 함수가 생성될때,
-> 함수 호이스팅을 의미하는건가?
