## 19장: 프로토타입
---

### 19.3 프로토타입 객체

객체간 상속을 구현한다. 그래서 프로토타입을 상속받으면 자식 객체는 그 프로퍼티를 자유롭게 사용할 수 있다.

```jsx
function Panda(age, name){
    this.age = age;
    this.name = name;
}

Panda.prototype.eat = function(){
    if(this.age >= 1) console.log("나는 죽순을 먹어용");
    else console.log("나는 우유를 먹어용");
}

const fubao = new Panda(4, '푸바오');
```

### `prototype` vs `__proto__` vs `Object.getPrototypeOf` 
- `Panda.prototype`: `fuboa` 객체가 상속받는 프로토타입 객체
- `fubao.__proto__`: `fubao`의 프로토타입 객체를 가져오는 비표준 접근법
- `Object.getPrototypeOf(fubao)`: `fubao`의 프로토타입 객체를 가져오는 표준 접근법

### `__proto__`

> `fubao.__proto__`: `fubao`의 프로토타입 객체를 가져오는 비표준 접근법

[[Prototype]]` 슬롯에 간접적으로 접근

// TODO
<details>
  <summary>
    내부슬롯
  </summary>
  자바스크립트는 원칙적으로 내부 슬롯과 내부 메서를 직접적으로 접근 또는 호출 할 수 없음. 그러나 `__proto__`를 통해 내부 슬롯 [[Prototype]]을 접근할 수 있음.
</details>

<img width="314" alt="image" src="https://github.com/dev-hamster/study-js-deep-dive/assets/123740296/c34707e6-81e4-464f-b570-a247db7ad859">


**`__proto__`를 사용하는 이유**
```jsx
const fubao = {};
const aiBao = {};

// DO NOT
fubao.__proto__ = aibao;
aibao.__proto__ = fubak;
```
프로토타입을 교체할 수 없게 만들어 프로토타입 체인의 순환참조를 막는다.
프로토타입 체인은 단방향 링크드 리스트로 구현되어야 한다.

// TODO

### `prototype`
> `Panda.prototype`: `fuboa` 객체가 상속받는 프로토타입 객체
생성자 함수로서 호출할 수 있는 함수인 constructor만 소유함

**`__proto__` vs `prototype`**
|구분|소유|값|사용 주체|사용목적
|--|--|--|--|--|
|`__proto__`|모든 객체|프로토타입 참조|모든 객체|객체가 자신의 프로터타입에 접근, 프로토타입 교체
|`prototype`|constructor|프로토타입 참조|생성자 함수|생성자 함수가 자신이 생성할 객체의 프로토타입을 할당하기 위해 사용

### constructor 프로퍼티와 생성자 함수
자기자신을 가리킴
생성자 함수가 생성될 때, 이 연결이 이뤄짐


---
### ?
p272. 이 연결은 생성자 함수가 생성될때,
-> 함수 호이스팅을 의미하는건가?

### 19.4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

constructor 역할: 인스턴스와 생성자 함수의 연결
```jsx
const obj = {};
console.log(obj.constructor == Object); // true
```
객체 리터럴로 생성한 obj의 constructor은 Object이다.
객체 리터럴로 생성한 `obj`는 어떻게 Object 생성자 함수와 연결됐을까?

### 추상 연산 OrdinaryObjectCreate
<details>
  <summary>
    추상 연산이란?
  </summary>
    ECMAScript의 내부 동작의 구현 알고리즘 표현
</details>

**Object 생성자 함수로 객체 생성시 OrdinaryObjectCreate 동작**
OrdinaryObjectCreate를 호출해 빈 객체 생성하고 아래의 동작 방식을 가진다.

```jsx
// 1. new.target이 undefined나 Object가 아닌 경우
// 인스턴스 -> Foo.prototype -> Object.prototype 순으로 프로토타입 체인이 생성
class Foo extends Object{}
new Foo(); // Foo {}

// 2. Object 생성자 함수에 의한 객체 생성
// 인수가 전달되지 않았응ㄹ 때 추상 연산 OrdinaryObjectCreate를 호출해 빈 객체 생성
let obj = new Object();
console.log(obj); // {}

// 3. 인수가 전달된 경우에는 인수를 객체로 변환
// Nunber 객체 생성
obj = new Object(123);
console.log(obj); // Number {123}
```

**객체 리터럴로 생성시 OrdinaryObjectCreate 동작**
OrdinaryObjectCreate를 호출해 빈 객체 생성한다.

```jsx
const obj = {}; 
```

객체 리터럴은 추상연산을 통해 Object 생성자 함수와 연결한다. 리터럴 표기법에 의해 생성된 객체도 상속을 위해 프로토타입이 필요하다.
따라서 가상적인 생성자 함수를 갖는다. 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재한다.

```jsx
const foo = "hello";
console.log(foo); // hello
```
// TODO

