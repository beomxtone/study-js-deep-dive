## 07장: 연산자
---

연산자는 값을 만든다

### **7.1 산술 연산자**
- 새로운 숫자 값을 만듦
- *산술 연산이 불가능한 경우 NaN을 반환

### 산술 연산자와 부수효과
이항 산술 연산자는 부수효과를 일으키지 않는다.
```javascript
5 + 2; // 7
```

단항 산술 연산자는 부수효과를 일으킨다
암묵적 할당이 일어난다.
```jsx
var x = 1;
x++;
console.log(x); // 2
```

### `+`, `-` 단항 연산자
피연산자를 숫자 타입으로 변환해서 반환
```jsx
var x = '1';
console.log(+x); // 1
console.log(x); // '1'


var y = '1';
console.log(-y); // -1
console.log(y); // '1'
```

숫자 타입으로 변환할 수 없으면 NaN을 반환
```jsx
var x = 'one';
console.log(+x); // NaN
```

**암묵적 타입 변환(타입 강제 변환)**
/

### 문자열 연결 연산자
피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작
```jsx
'1' + 2; // '12'
'1' + undefined; // '1undefined'
```

### **7.2 할당 연산자**
우항의 피연산자의 `평가 결과`를 좌항에 있는 변수에 할당

```jsx
var a, b, c;

// (1) c = 0: 0으로 평가
// (2) b = 0: 0으로 평가
// (3) a = 0: 0으로 평가
a = b = c = 0;
```

### **7.3 비교 연산자**
### 동등 비교 연산자
**`==`**
x와 y의 `값`이 같음
**`!=`**
x와 y의 `값`이 다름

```jsx
5 == '5'; // true
```
`암묵적 타입 변환`이 이뤄짐
예측하기 어렵다

### 일치 비교 연산자 
**`===`**
x와 y의 `값`과 타입이 같음
**`!==`**
x와 y의 `값`과 타입이 다름

```jsx
5 === '5'; // false
```
예측하기 쉽다!

예외
```jsx
NaN === NaN; // false
Number.isNaN(NaN); // true

-0 === +0; // true
```

### **7.5 논리 연산자** 
**!** 
언제나 `boolean` 반환
암묵적으로 타입 변환이 일어남
```jsx
a = '';
!a; // false
```

### **7.6 쉼표 연산자** 
마지막 피연산자의 평과 결과를 반환
```jsx
var x, y, z;
x = 1, y = 2, z = 3; // 3
```

### **7.7 그룹 연산자** 
`()`로 평가 우선순위 부여

### **7.13 연산자 결합 순서** 
좌항 -> 우항 ...(생략), <, <=, >, >=


### 코멘트
+0, -0은 왜 존재하지
https://medium.com/coding-at-dawn/is-negative-zero-0-a-number-in-javascript-c62739f80114

p86. && 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.

드모르간 법칙 잘 쓰시나여?
> chatGPT
> - 복잡한 식 단순화: 복잡한 논리 식을 더 간결하고 이해하기 쉬운 형태로 변환할 수 있습니다. 이로 인해 코드의 가독성이 향상되며, 코드를 분석하고 유지보수하기가 더 용이해집니다.
> - 조건 부정 표현: 드 모르간 법칙을 사용하면 AND와 OR 조건을 부정한 형태로 표현할 수 있습니다. 부정된 조건은 원래 조건의 부분 집합이므로, 코드에서 반대로 생각해야 하는 경우에도 논리적으로 더 쉽게 다룰 수 있습니다.

